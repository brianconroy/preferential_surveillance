

###########
# functions
###########
# betaPoissonUpdate: updates beta according to RW Metropolis Hastings
# thetaPoissonUpdate: Gibbs sampler for independent random effects
# phiPoissonUpdate: RW-MW update for spatial random effects


###################
# betaPoissonUpdate
###################
# updates beta according to RW Metropolis Hastings
# proposal value generated by random walk,
# acceptance probability by log likelihoods
# returns a list of: beta (updated value),
# accept (indicator for acceptance)

## arguments
# x: matrix of covariates
# y: count response vector
# beta: regression parameters
# offset: regression offset
# prior.meanbeta: prior beta mean
# prior.varbeta: prior beta var
# beta.tune: standard deviation of RW proposal distribution
betaPoissonUpdate <- function(x, y, beta, offset, prior.meanbeta, prior.varbeta, beta.tune){
  
  
  # RW propose beta
  beta.new <- beta
  for (i in 1:length(beta.new)){
    beta.new[i] <- rnorm(1, beta[i], beta.tune)
  }
  
  
  # likelihoods
  lp.curr <- x %*% beta + offset
  lp.prop <- x %*% beta.new + offset
  like.curr <- 0
  like.prop <- 0
  for (j in 1:nrow(lp.curr)){
    like.curr <- like.curr + (y[j]*lp.curr[j] - exp(lp.curr[j]))
    like.prop <- like.prop + (y[j]*lp.prop[j] - exp(lp.prop[j]))
  }
  like.diff <- like.prop - like.curr
  
  
  # priors
  prior.curr <- 0
  prior.prop <- 0
  for (i in 1:length(beta.new)){
    prior.curr <- 0.5 * (beta[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
    prior.prop <- 0.5 * (beta.new[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
  }
  prior.diff <- prior.prop - prior.curr
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(like.diff + prior.diff)
  if(runif(1) <= acceptance) {
    out$beta <- beta.new
    out$accept <- 1
  } else { 
    out$beta <- beta
    out$accept <- 0
  }
  
  
  return(out)
  
  
}


betaPoissonIntercept <- function(x, y, beta, offset, prior.meanbeta, prior.varbeta, beta.tune){
  
  
  # RW propose beta
  beta.new <- beta
  beta.new[1] <- rnorm(1, beta[1], beta.tune)
  
  
  # likelihoods
  lp.curr <- x %*% beta + offset
  lp.prop <- x %*% beta.new + offset
  like.curr <- 0
  like.prop <- 0
  for (j in 1:nrow(lp.curr)){
    like.curr <- like.curr + (y[j]*lp.curr[j] - exp(lp.curr[j]))
    like.prop <- like.prop + (y[j]*lp.prop[j] - exp(lp.prop[j]))
  }
  like.diff <- like.prop - like.curr
  
  
  # priors
  prior.curr <- 0
  prior.prop <- 0
  for (i in 1:length(beta.new)){
    prior.curr <- 0.5 * (beta[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
    prior.prop <- 0.5 * (beta.new[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
  }
  prior.diff <- prior.prop - prior.curr
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(like.diff + prior.diff)
  if(runif(1) <= acceptance) {
    out$beta <- beta.new
    out$accept <- 1
  } else { 
    out$beta <- beta
    out$accept <- 0
  }
  
  
  return(out)
  
  
}


betaPoissonSlope <- function(x, y, beta, offset, prior.meanbeta, prior.varbeta, beta.tune){
  
  
  # RW propose beta
  beta.new <- beta
  for (i in 2:length(beta.new)){
    beta.new[i] <- rnorm(1, beta[i], beta.tune)
  }
  
  
  # likelihoods
  lp.curr <- x %*% beta + offset
  lp.prop <- x %*% beta.new + offset
  like.curr <- 0
  like.prop <- 0
  for (j in 1:nrow(lp.curr)){
    like.curr <- like.curr + (y[j]*lp.curr[j] - exp(lp.curr[j]))
    like.prop <- like.prop + (y[j]*lp.prop[j] - exp(lp.prop[j]))
  }
  like.diff <- like.prop - like.curr
  
  
  # priors
  prior.curr <- 0
  prior.prop <- 0
  for (i in 1:length(beta.new)){
    prior.curr <- 0.5 * (beta[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
    prior.prop <- 0.5 * (beta.new[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
  }
  prior.diff <- prior.prop - prior.curr
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(like.diff + prior.diff)
  if(runif(1) <= acceptance) {
    out$beta <- beta.new
    out$accept <- 1
  } else { 
    out$beta <- beta
    out$accept <- 0
  }
  
  
  return(out)
  
  
}


alphaPoissonUpdate <- function(x, y, alpha, loc.pred, beta.c, proposal.sd.alpha){
  
  
  # RW propose alpha
  alpha.new <- rnorm(1, alpha, proposal.sd.alpha)
  
  
  # likelihoods
  lp.curr <- x %*% beta.c + alpha * loc.pred
  lp.prop <- x %*% beta.c + alpha.new * loc.pred
  like.curr <- 0
  like.prop <- 0
  for (j in 1:nrow(lp.curr)){
    like.curr <- like.curr + (y[j]*lp.curr[j] - exp(lp.curr[j]))
    like.prop <- like.prop + (y[j]*lp.prop[j] - exp(lp.prop[j]))
  }
  like.diff <- like.prop - like.curr
  
  
  # priors
  prior.curr <- dnorm(alpha, 1, 10, log=T)
  prior.prop <- dnorm(alpha.new, 1, 10, log=T)
  prior.diff <- prior.prop - prior.curr
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(like.diff + prior.diff)
  if(runif(1) <= acceptance) {
    out$alpha <- alpha.new
    out$accept <- 1
  } else { 
    out$alpha <- alpha
    out$accept <- 0
  }
  
  
  return(out)
  
  
}


alphaPoissonUpdateCC <- function(x, y.case, y.control, alpha, loc.pred, beta.case, beta.control, proposal.sd.alpha){
  
  
  # RW propose alpha
  alpha.new <- abs(rnorm(1, alpha, proposal.sd.alpha))
  
  
  # likelihoods
  like.curr <- 0
  like.prop <- 0
  
  
  lp.curr <- x %*% beta.case + alpha * loc.pred
  lp.prop <- x %*% beta.case + alpha.new * loc.pred
  for (j in 1:nrow(lp.curr)){
    like.curr <- like.curr + (y.case[j]*lp.curr[j] - exp(lp.curr[j]))
    like.prop <- like.prop + (y.case[j]*lp.prop[j] - exp(lp.prop[j]))
  }
  
  
  lp.curr <- x %*% beta.control + alpha * loc.pred
  lp.prop <- x %*% beta.control + alpha.new * loc.pred
  for (j in 1:nrow(lp.curr)){
    like.curr <- like.curr + (y.control[j]*lp.curr[j] - exp(lp.curr[j]))
    like.prop <- like.prop + (y.control[j]*lp.prop[j] - exp(lp.prop[j]))
  }
  
  
  like.diff <- like.prop - like.curr
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(like.diff)
  if(runif(1) <= acceptance) {
    out$alpha <- alpha.new
    out$accept <- 1
  } else { 
    out$alpha <- alpha
    out$accept <- 0
  }
  
  
  return(out)
  
  
}


logit <- function(x){log(x/(1-x))}


expit <- function(x){exp(x)/(1+exp(x))}


logPost <- function(y, x, beta, offset){
  
  
  prob1 <- expit(x %*% beta + offset)
  like <- sum(dbinom(y, 1, prob1, log=TRUE))
  prior <- sum(dnorm(beta, 0, 10, log=TRUE))
  return(like + prior)
  
  
}


betaLogisticUpdate <- function(x, y, beta, beta.tune, offset=0){
  
  
  # RW propose beta
  beta.new <- beta
  for (i in 1:length(beta.new)){
    beta.new[i] <- rnorm(1, beta[i], beta.tune)
  }
  
  
  # compute log posteriors
  lp.cur <- logPost(y, x, beta, offset)
  lp.new <- logPost(y, x, beta.new, offset)
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(lp.new - lp.cur)
  if(runif(1) <= acceptance) {
    out$beta <- beta.new
    out$accept <- 1
  } else { 
    out$beta <- beta
    out$accept <- 0
  }
  
  
  return(out)
  
  
}


betaLogisticSlope <- function(x, y, beta, beta.tune, offset=0){
  
  
  # RW propose beta
  beta.new <- beta
  for (i in 2:length(beta.new)){
    beta.new[i] <- rnorm(1, beta[i], beta.tune)
  }
  
  # compute log posteriors
  lp.cur <- logPost(y, x, beta, offset)
  lp.new <- logPost(y, x, beta.new, offset)
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(lp.new - lp.cur)
  if(runif(1) <= acceptance) {
    out$beta <- beta.new
    out$accept <- 1
  } else { 
    out$beta <- beta
    out$accept <- 0
  }
  
  
  return(out)
  
  
}


betaLogisticIntercept <- function(x, y, beta, beta.tune, offset=0){
  
  
  # RW propose beta
  beta.new <- beta
  beta.new[1] <- rnorm(1, beta[1], beta.tune)
  
  # compute log posteriors
  lp.cur <- logPost(y, x, beta, offset)
  lp.new <- logPost(y, x, beta.new, offset)
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(lp.new - lp.cur)
  if(runif(1) <= acceptance) {
    out$beta <- beta.new
    out$accept <- 1
  } else { 
    out$beta <- beta
    out$accept <- 0
  }
  
  
  return(out)
  
  
}


# updates locational covariates
# via joint location/conditional
# likelihood, not location alone
betaLocationalUpdate <- function(x.loc, y.loc, x.loc.sub, x.count, y.count, 
                                 beta.loc, beta.count, alpha, beta.tune, w.full=0, w.sub=0){
  
  
  # RW propose beta
  beta.new <- beta.loc
  for (i in 1:length(beta.new)){
    beta.new[i] <- rnorm(1, beta.loc[i], beta.tune)
  }
  
  
  # compute log posteriors, locational
  lp.cur <- logPost(y.loc, x.loc, beta.loc, offset=w.full)
  lp.new <- logPost(y.loc, x.loc, beta.new, offset=w.full)
  
  
  # add likelihood contribution from counts
  linpred.cur <- x.count %*% beta.count + alpha * expit(x.loc.sub %*% beta.loc + w.sub)
  linpred.new <- x.count %*% beta.count + alpha * expit(x.loc.sub %*% beta.new + w.sub)
  like.cur <- 0
  like.new <- 0
  for (j in 1:nrow(linpred.cur)){
    like.cur <- like.cur + (y.count[j]*linpred.cur[j] - exp(linpred.cur[j]))
    like.new <- like.new + (y.count[j]*linpred.new[j] - exp(linpred.new[j]))
  }
  
  
  lp.cur <- lp.cur + like.cur
  lp.new <- lp.new + like.new
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(lp.new - lp.cur)
  if(runif(1) <= acceptance) {
    out$beta <- beta.new
    out$accept <- 1
  } else { 
    out$beta <- beta.loc
    out$accept <- 0
  }
  
  
  return(out)
  
}


########################
# betaPsIntegratedUpdate
########################
  # updates beta by integrating preferentially 
  # sampled data with areal data 

## arguments
  # x.spat: matrix of covariates for spatial data
  # y.spat: count response vector for spatial data
  # x.spat: matrix of covariates for spatial data
  # y.spat: count response vector for spatial data
  # beta: regression parameters
  # offset.spat: offset for spatial data
  # offset.ps: offset for preferentially sampled data
  # prior.meanbeta: prior beta mean
  # prior.varbeta: prior beta var
  # beta.tune: standard deviation of RW proposal distribution
betaPsIntegratedUpdate <- function(x.spat, y.spat, x.ps, y.ps, beta, offset.spat, offset.ps,
                                   prior.meanbeta, prior.varbeta, beta.tune){
  
  
  # RW propose beta
  beta.new <- beta
  for (i in 1:length(beta.new)){
    beta.new[i] <- rnorm(1, beta[i], beta.tune)
  }
  
  
  # likelihoods
  like.curr <- 0
  like.prop <- 0
  
  
  # areal contribution
  for (d in 1:length(x.spat)){
    x.d <- x.spat[[d]]
    y.d <- y.spat[[d]]
    offset.d <- offset.spat[[d]]
    lp.curr.d <- x.d %*% beta + offset.d
    lp.prop.d <- x.d %*% beta.new + offset.d
    for (j in 1:nrow(lp.curr.d)){
      like.curr <- like.curr + (y.d[j]*lp.curr.d[j] - exp(lp.curr.d[j]))
      like.prop <- like.prop + (y.d[j]*lp.prop.d[j] - exp(lp.prop.d[j]))
    }
  }
  
  
  # preferential sampling contribution
  lp.curr <- x.ps %*% beta + offset.ps
  lp.prop <- x.ps %*% beta.new + offset.ps
  for (j in 1:nrow(lp.curr)){
    like.curr <- like.curr + (y.ps[j]*lp.curr[j] - exp(lp.curr[j]))
    like.prop <- like.prop + (y.ps[j]*lp.prop[j] - exp(lp.prop[j]))
  }

  
  like.diff <- like.prop - like.curr
  
  
  # priors
  prior.curr <- 0
  prior.prop <- 0
  for (i in 1:length(beta.new)){
    prior.curr <- 0.5 * (beta[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
    prior.prop <- 0.5 * (beta.new[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
  }
  prior.diff <- prior.prop - prior.curr
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(like.diff + prior.diff)
  if(runif(1) <= acceptance) {
    out$beta <- beta.new
    out$accept <- 1
  } else { 
    out$beta <- beta
    out$accept <- 0
  }
  
  
  return(out)
  
  
}


######################
# betaIntegratedUpdate
######################
  # updates beta according to RW Metropolis Hastings
  # proposal value generated by random walk,
  # acceptance probability by log likelihoods
  # returns a list of: beta (updated value),
  # accept (indicator for acceptance)

## arguments
  # x: matrix of covariates
  # y: count response vector
  # beta: regression parameters
  # offset: regression offset
  # prior.meanbeta: prior beta mean
  # prior.varbeta: prior beta var
  # beta.tune: standard deviation of RW proposal distribution
betaIntegratedUpdate <- function(x.list, y.list, beta, offset, prior.meanbeta, prior.varbeta, beta.tune){
  
  
  # RW propose beta
  beta.new <- beta
  for (i in 1:length(beta.new)){
    beta.new[i] <- rnorm(1, beta[i], beta.tune)
  }
  
  
  # likelihoods
  like.curr <- 0
  like.prop <- 0
  for (d in 1:length(x.list)){
    x.d <- x.list[[d]]
    y.d <- y.list[[d]]
    offset.d <- offset[[d]]
    lp.curr.d <- x.d %*% beta + offset.d
    lp.prop.d <- x.d %*% beta.new + offset.d
    for (j in 1:nrow(lp.curr.d)){
      like.curr <- like.curr + (y.d[j]*lp.curr.d[j] - exp(lp.curr.d[j]))
      like.prop <- like.prop + (y.d[j]*lp.prop.d[j] - exp(lp.prop.d[j]))
    }
  }
  like.diff <- like.prop - like.curr
  
  
  # priors
  prior.curr <- 0
  prior.prop <- 0
  for (i in 1:length(beta.new)){
    prior.curr <- 0.5 * (beta[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
    prior.prop <- 0.5 * (beta.new[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
  }
  prior.diff <- prior.prop - prior.curr
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(like.diff + prior.diff)
  if(runif(1) <= acceptance) {
    out$beta <- beta.new
    out$accept <- 1
  } else { 
    out$beta <- beta
    out$accept <- 0
  }
  
  
  return(out)
  
  
}


##########################
# betaIntegratedUnifUpdate
##########################
# updates beta according to RW Metropolis Hastings
# proposal value generated by random walk,
# acceptance probability by log likelihoods
# returns a list of: 
#   beta (updated value),
#   accept (indicator for acceptance)

## arguments
#   x: matrix of covariates
#   y: count response vector
#   beta: regression parameters
#   offset: regression offset
#   prior.meanbeta: prior beta mean
#   prior.varbeta: prior beta var
#   beta.tune: standard deviation of RW proposal distribution
betaIntegratedUnifUpdate <- function(x.list, y.list, beta, offset, prior.meanbeta, prior.varbeta, beta.tune){
  
  
  # RW propose beta
  beta.new <- beta
  for (i in 1:length(beta.new)){
    beta.new[i] <- rnorm(1, beta[i], beta.tune)
  }
  
  
  # likelihoods
  like.curr <- 0
  like.prop <- 0
  for (d in 1:length(x.list$spatial)){
    x.d <- x.list$spatial[[d]]
    y.d <- y.list$spatial[[d]]
    offset.d <- offset[[d]]
    lp.curr.d <- x.d %*% beta + offset.d
    lp.prop.d <- x.d %*% beta.new + offset.d
    for (j in 1:nrow(lp.curr.d)){
      like.curr <- like.curr + (y.d[j]*lp.curr.d[j] - exp(lp.curr.d[j]))
      like.prop <- like.prop + (y.d[j]*lp.prop.d[j] - exp(lp.prop.d[j]))
    }
  }
  x.u <- x.list$survey
  y.u <- y.list$survey
  lp.curr.u <- x.u %*% beta
  lp.prop.u <- x.u %*% beta.new
  for (j in 1:nrow(lp.curr.u)){
    like.curr <- like.curr + (y.u[j]*lp.curr.u[j] - exp(lp.curr.u[j]))
    like.prop <- like.prop + (y.u[j]*lp.prop.u[j] - exp(lp.prop.u[j]))
  }
  
  
  like.diff <- like.prop - like.curr
  
  
  # priors
  prior.curr <- 0
  prior.prop <- 0
  for (i in 1:length(beta.new)){
    prior.curr <- 0.5 * (beta[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
    prior.prop <- 0.5 * (beta.new[i] - prior.meanbeta[i])^2 / prior.varbeta[i]
  }
  prior.diff <- prior.prop - prior.curr
  
  
  # accept or reject
  out <- list()
  acceptance <- exp(like.diff + prior.diff)
  if(runif(1) <= acceptance) {
    out$beta <- beta.new
    out$accept <- 1
  } else { 
    out$beta <- beta
    out$accept <- 0
  }
  
  
  return(out)
  
  
}


#####################
## thetaPoissonUpdate
#####################
# update independent REs by metropolis hastings random walk algorithm
# returns list of theta (updated value), & accept (indicator)

## arguments
# y: count response vector
# theta: vector of theta values
# offset: regression offset
# theta.tune: sd of proposal dist
# sigma2: estimate for var of RE dist
thetaPoissonUpdate <- function(y, theta, offset, theta.tune, sigma2){
  
  
  # update each random effect separately
  theta.new <- theta
  accept <- 0
  for (i in 1:length(theta)){
    
    
    # proposal theta
    theta.prop <- rnorm(1, theta.new[i], theta.tune)
    
    
    # likelihoods
    lp.curr <- offset[i] + theta.new[i]
    lp.prop <- offset[i] + theta.prop
    like.curr <- y[i] * lp.curr - exp(lp.curr)
    like.prop <- y[i] * lp.prop - exp(lp.prop)
    like.diff <- like.prop - like.curr
    
    
    # priors
    prior.prop <- -0.5*(theta.prop^2)/sigma2
    prior.curr <- -0.5*(theta.new[i]^2)/sigma2
    prior.diff <- prior.prop - prior.curr
    
    
    # accept or reject
    acceptance <- exp(like.diff + prior.diff)
    if(runif(1) <= acceptance) {
      theta.new[i] <- theta.prop
      accept <- accept + 1
    }
    
    
  }
  
  
  out <- list()
  out$theta <- theta.new
  out$accept <- accept
  return(out)
  
  
}


##################
# phiPoissonUpdate
##################
# betaPoissonUpdate: updates spatial random effects according to RW Metropolis Hastings
# returns list of phi (updated value), # accepted proposals

## arguments
# y: count response vector
# W: neighbor adjacency matrix
# nNeighbors: vector of # neighbors
# phi: vector of phi values to update
# tau2: spatial variance parameter value
# offset: offset
# phi.tune: phi tuning parameter (> 0)
# rho: spatial strength of association [0, 1]
phiPoissonUpdate <- function(y, W, nNeighbors, phi, tau2, offset, phi.tune, rho=1){


  # update each random effect separately
  phi.new <- phi
  accept <- 0
  for (i in 1:length(phi)){


    # prior variance
    prior.var <- tau2/(rho*nNeighbors[i] + 1 - rho)


    # prior mean
    prior.mean <- rho*sum(W[i, ]*phi)/(rho*nNeighbors[i] + 1 - rho)


    # proposal
    prop.var <- prior.var*phi.tune
    phi.prop <- rnorm(1, phi.new[i], sqrt(prop.var))


    # likelihoods
    lp.curr <- offset[i] + phi.new[i]
    lp.prop <- offset[i] + phi.prop
    like.curr <- y[i] * lp.curr - exp(lp.curr)
    like.prop <- y[i] * lp.prop - exp(lp.prop)
    like.diff <- like.prop - like.curr


    # priors
    prior.curr <- -0.5*((phi.new[i]-prior.mean)^2)/prior.var
    prior.prop <- -0.5*((phi.prop-prior.mean)^2)/prior.var
    prior.diff <- prior.prop - prior.curr


    # accept or reject
    acceptance <- exp(like.diff + prior.diff)
    if(runif(1) <= acceptance) {
      phi.new[i] <- phi.prop
      accept <- accept + 1
    }


  }


  out <- list()
  out$phi <- phi.new
  out$accept <- accept
  return(out)


}


common.Wcheckformat.leroux <- function(W, n, fix.rho, rho)
{
  #### If fix.rho=TRUE and rho=0 set up a dummy W matrix    
  if(fix.rho & rho==0)
  {
    ## Set up a dummy W matrix to use in the code as it will not affect the results
    W <- array(0, c(n,n))
    for(r in 2:n)
    {
      W[(r-1), r] <- 1   
      W[r, (r-1)] <- 1
    }
  }else
  {
  }        
  
  
  #### Check validity of inputed W matrix
  if(!is.matrix(W)) stop("W is not a matrix.", call.=FALSE)
  if(nrow(W)!= n) stop("W has the wrong number of rows.", call.=FALSE)
  if(ncol(W)!= n) stop("W has the wrong number of columns.", call.=FALSE)
  if(sum(is.na(W))>0) stop("W has missing 'NA' values.", call.=FALSE)
  if(!is.numeric(W)) stop("W has non-numeric values.", call.=FALSE)
  if(min(W)<0) stop("W has negative elements.", call.=FALSE)
  if(sum(W!=t(W))>0) stop("W is not symmetric.", call.=FALSE)
  if(min(apply(W, 1, sum))==0) stop("W has some areas with no neighbours (one of the row sums equals zero).", call.=FALSE)    
  
  
  #### Create the triplet form
  W.triplet <- c(NA, NA, NA)
  for(i in 1:n)
  {
    for(j in 1:n)
    {
      if(W[i,j]>0)
      {
        W.triplet <- rbind(W.triplet, c(i,j, W[i,j]))     
      }else{}
    }
  }
  W.triplet <- W.triplet[-1, ]     
  n.triplet <- nrow(W.triplet) 
  W.triplet.sum <- tapply(W.triplet[ ,3], W.triplet[ ,1], sum)
  n.neighbours <- tapply(W.triplet[ ,3], W.triplet[ ,1], length)
  
  
  #### Create the start and finish points for W updating
  W.begfin <- array(NA, c(n, 2))     
  temp <- 1
  for(i in 1:n)
  {
    W.begfin[i, ] <- c(temp, (temp + n.neighbours[i]-1))
    temp <- temp + n.neighbours[i]
  }
  
  
  #### Return the critical quantities
  results <- list(W=W, W.triplet=W.triplet, n.triplet=n.triplet, W.triplet.sum=W.triplet.sum, n.neighbours=n.neighbours, W.begfin=W.begfin)
  return(results)   
}


quadform <- function(Wtriplet, Wtripletsum, n_triplet, nsites, 
                     phi, theta, rho){
  
  
  # Compute a quadratic form for the random effects
  # Create new objects 
  tau2_quadform <- 0
  tau2_phisq <- 0
  
  
  # Compute the off diagonal elements of the quadratic form
  for(l in 1:n_triplet)
  {
    row <- Wtriplet[l, 1]
    col <- Wtriplet[l, 2]
    tau2_quadform = tau2_quadform + phi[(Wtriplet[l,1])] * theta[(Wtriplet[l,2])] * Wtriplet[l,3]
  }
  
  
  # Compute the diagonal elements of the quadratic form          
  for(l in 1:nsites)
  {
    tau2_phisq <- tau2_phisq + phi[l] * theta[l] * (rho * Wtripletsum[l] + 1 - rho)  
  }
  
  
  # Compute the quadratic form
  tau2_posteriorscale <- 0.5 * (tau2_phisq - rho * tau2_quadform)
  
  
  # Return the simulated value
  return(tau2_posteriorscale)
  
  
}


common.Wcheckformat <- function(W, n)
{
  #### Check validity of inputed W matrix
  if(!is.matrix(W)) stop("W is not a matrix.", call.=FALSE)
  if(nrow(W)!= n) stop("W has the wrong number of rows.", call.=FALSE)
  if(ncol(W)!= n) stop("W has the wrong number of columns.", call.=FALSE)
  if(sum(is.na(W))>0) stop("W has missing 'NA' values.", call.=FALSE)
  if(!is.numeric(W)) stop("W has non-numeric values.", call.=FALSE)
  if(min(W)<0) stop("W has negative elements.", call.=FALSE)
  if(sum(W!=t(W))>0) stop("W is not symmetric.", call.=FALSE)
  if(min(apply(W, 1, sum))==0) stop("W has some areas with no neighbours (one of the row sums equals zero).", call.=FALSE)    
  
  
  #### Create the triplet form
  W.triplet <- c(NA, NA, NA)
  for(i in 1:n)
  {
    for(j in 1:n)
    {
      if(W[i,j]>0)
      {
        W.triplet <- rbind(W.triplet, c(i,j, W[i,j]))     
      }else{}
    }
  }
  W.triplet <- W.triplet[-1, ]     
  n.triplet <- nrow(W.triplet) 
  W.triplet.sum <- tapply(W.triplet[ ,3], W.triplet[ ,1], sum)
  n.neighbours <- tapply(W.triplet[ ,3], W.triplet[ ,1], length)
  
  
  #### Create the start and finish points for W updating
  W.begfin <- array(NA, c(n, 2))     
  temp <- 1
  for(i in 1:n)
  {
    W.begfin[i, ] <- c(temp, (temp + n.neighbours[i]-1))
    temp <- temp + n.neighbours[i]
  }
  
  
  #### Return the critical quantities
  results <- list(W=W, W.triplet=W.triplet, n.triplet=n.triplet, W.triplet.sum=W.triplet.sum, n.neighbours=n.neighbours, W.begfin=W.begfin)
  return(results)   
}
